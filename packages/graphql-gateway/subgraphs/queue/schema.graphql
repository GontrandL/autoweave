extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.3", import: ["@key", "@shareable", "@provides", "@requires", "@external", "@tag", "@inaccessible"])

type Query {
  jobs(tenantId: String, queueName: String, status: JobStatus): [Job!]! @auth(requires: ["queue:read"])
  job(id: ID!): Job @auth(requires: ["queue:read"], tenantIsolated: true)
  queues(tenantId: String): [Queue!]! @auth(requires: ["queue:read"])
  queue(name: String!): Queue @auth(requires: ["queue:read"], tenantIsolated: true)
  queueStats(tenantId: String): QueueStats! @auth(requires: ["queue:read"])
  jobMetrics(queueName: String, timeRange: TimeRange!): JobMetrics! @auth(requires: ["queue:read"])
  deadLetterJobs(queueName: String!): [Job!]! @auth(requires: ["queue:read"])
}

type Mutation {
  createJob(input: CreateJobInput!): Job! @auth(requires: ["queue:write"])
  updateJob(id: ID!, input: UpdateJobInput!): Job! @auth(requires: ["queue:write"], tenantIsolated: true)
  deleteJob(id: ID!): Boolean! @auth(requires: ["queue:delete"], tenantIsolated: true)
  retryJob(id: ID!): Job! @auth(requires: ["queue:write"], tenantIsolated: true)
  cancelJob(id: ID!): Job! @auth(requires: ["queue:write"], tenantIsolated: true)
  pauseQueue(name: String!): Queue! @auth(requires: ["queue:write"], tenantIsolated: true)
  resumeQueue(name: String!): Queue! @auth(requires: ["queue:write"], tenantIsolated: true)
  purgeQueue(name: String!): Int! @auth(requires: ["queue:delete"], tenantIsolated: true)
  createQueue(input: CreateQueueInput!): Queue! @auth(requires: ["queue:write"])
  updateQueue(name: String!, input: UpdateQueueInput!): Queue! @auth(requires: ["queue:write"], tenantIsolated: true)
  deleteQueue(name: String!): Boolean! @auth(requires: ["queue:delete"], tenantIsolated: true)
  bulkRetryJobs(queueName: String!, jobIds: [ID!]!): Int! @auth(requires: ["queue:write"])
  rescheduleJob(id: ID!, delay: Int!): Job! @auth(requires: ["queue:write"], tenantIsolated: true)
}

type Subscription {
  jobStatusChanged(queueName: String): Job! @auth(requires: ["queue:read"])
  queueStatusChanged(tenantId: String): Queue! @auth(requires: ["queue:read"])
  jobProgress(jobId: ID!): JobProgress! @auth(requires: ["queue:read"])
}

type Job @key(fields: "id") {
  id: ID!
  name: String!
  queueName: String!
  data: JSON!
  options: JobOptions!
  status: JobStatus!
  progress: JobProgress!
  result: JSON
  error: JobError
  attempts: Int!
  maxAttempts: Int!
  delay: Int!
  priority: Int!
  tenantId: String!
  userId: String!
  agentId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  processedAt: DateTime
  finishedAt: DateTime
  failedAt: DateTime
  logs: [JobLog!]!
  dependencies: [Job!]!
  dependents: [Job!]!
  tags: [String!]!
  isActive: Boolean!
  nextRunAt: DateTime
  repeatOptions: RepeatOptions
}

type Queue @key(fields: "name") {
  name: String!
  displayName: String!
  description: String
  tenantId: String!
  status: QueueStatus!
  settings: QueueSettings!
  stats: QueueStats!
  jobs: [Job!]!
  workers: [Worker!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  isActive: Boolean!
  isPaused: Boolean!
  concurrency: Int!
  rateLimiter: RateLimiter
}

type JobOptions {
  attempts: Int!
  backoff: BackoffOptions
  delay: Int!
  priority: Int!
  removeOnComplete: Int!
  removeOnFail: Int!
  repeat: RepeatOptions
  timeout: Int!
  ttl: Int!
  jobId: String
}

type BackoffOptions {
  type: BackoffType!
  delay: Int!
  factor: Float
  maxDelay: Int
}

type RepeatOptions {
  cron: String
  endDate: DateTime
  every: Int
  limit: Int
  pattern: String
  startDate: DateTime
  timezone: String
}

type JobProgress {
  current: Int!
  total: Int!
  percentage: Float!
  message: String
  data: JSON
  timestamp: DateTime!
}

type JobError {
  name: String!
  message: String!
  stack: String
  data: JSON
  timestamp: DateTime!
}

type JobLog {
  id: ID!
  jobId: ID!
  level: LogLevel!
  message: String!
  timestamp: DateTime!
  data: JSON
}

type QueueSettings {
  maxConcurrency: Int!
  rateLimiter: RateLimiterSettings
  retrySettings: RetrySettings!
  deadLetterSettings: DeadLetterSettings!
  cleanupSettings: CleanupSettings!
}

type RateLimiterSettings {
  max: Int!
  duration: Int!
  bounceBack: Boolean!
}

type RetrySettings {
  maxAttempts: Int!
  backoffType: BackoffType!
  backoffDelay: Int!
  backoffFactor: Float!
  maxBackoffDelay: Int!
}

type DeadLetterSettings {
  enabled: Boolean!
  maxRetries: Int!
  queueName: String!
}

type CleanupSettings {
  removeOnComplete: Int!
  removeOnFail: Int!
  maxAge: Int!
  maxCount: Int!
}

type QueueStats {
  totalJobs: Int!
  activeJobs: Int!
  waitingJobs: Int!
  completedJobs: Int!
  failedJobs: Int!
  delayedJobs: Int!
  pausedJobs: Int!
  throughput: Float!
  avgProcessingTime: Float!
  avgWaitTime: Float!
  errorRate: Float!
  timestamp: DateTime!
}

type JobMetrics {
  queueName: String!
  timeRange: TimeRange!
  totalJobs: Int!
  completedJobs: Int!
  failedJobs: Int!
  avgProcessingTime: Float!
  avgWaitTime: Float!
  throughput: Float!
  errorRate: Float!
  distribution: [JobDistribution!]!
  timeline: [JobTimelinePoint!]!
}

type JobDistribution {
  status: JobStatus!
  count: Int!
  percentage: Float!
}

type JobTimelinePoint {
  timestamp: DateTime!
  completed: Int!
  failed: Int!
  active: Int!
  waiting: Int!
}

type Worker @key(fields: "id") {
  id: ID!
  name: String!
  queueName: String!
  status: WorkerStatus!
  currentJob: Job
  processedJobs: Int!
  failedJobs: Int!
  lastActive: DateTime!
  createdAt: DateTime!
  host: String!
  pid: Int!
  memory: WorkerMemory!
  cpu: WorkerCPU!
}

type WorkerMemory {
  used: Float!
  total: Float!
  percentage: Float!
}

type WorkerCPU {
  usage: Float!
  loadAverage: [Float!]!
}

type RateLimiter {
  max: Int!
  duration: Int!
  bounceBack: Boolean!
  current: Int!
  resetTime: DateTime!
}

input CreateJobInput {
  name: String!
  queueName: String!
  data: JSON!
  options: JobOptionsInput
  agentId: String
  tags: [String!] = []
}

input UpdateJobInput {
  data: JSON
  options: JobOptionsInput
  tags: [String!]
}

input JobOptionsInput {
  attempts: Int = 3
  backoff: BackoffOptionsInput
  delay: Int = 0
  priority: Int = 0
  removeOnComplete: Int = 100
  removeOnFail: Int = 50
  repeat: RepeatOptionsInput
  timeout: Int = 30000
  ttl: Int = 0
  jobId: String
}

input BackoffOptionsInput {
  type: BackoffType!
  delay: Int!
  factor: Float = 2.0
  maxDelay: Int = 10000
}

input RepeatOptionsInput {
  cron: String
  endDate: DateTime
  every: Int
  limit: Int
  pattern: String
  startDate: DateTime
  timezone: String = "UTC"
}

input CreateQueueInput {
  name: String!
  displayName: String!
  description: String
  settings: QueueSettingsInput!
}

input UpdateQueueInput {
  displayName: String
  description: String
  settings: QueueSettingsInput
}

input QueueSettingsInput {
  maxConcurrency: Int = 5
  rateLimiter: RateLimiterSettingsInput
  retrySettings: RetrySettingsInput!
  deadLetterSettings: DeadLetterSettingsInput!
  cleanupSettings: CleanupSettingsInput!
}

input RateLimiterSettingsInput {
  max: Int!
  duration: Int!
  bounceBack: Boolean = false
}

input RetrySettingsInput {
  maxAttempts: Int = 3
  backoffType: BackoffType = EXPONENTIAL
  backoffDelay: Int = 1000
  backoffFactor: Float = 2.0
  maxBackoffDelay: Int = 30000
}

input DeadLetterSettingsInput {
  enabled: Boolean = true
  maxRetries: Int = 3
  queueName: String = "dead-letter"
}

input CleanupSettingsInput {
  removeOnComplete: Int = 100
  removeOnFail: Int = 50
  maxAge: Int = 86400
  maxCount: Int = 1000
}

input TimeRange {
  start: DateTime!
  end: DateTime!
}

enum JobStatus {
  WAITING
  ACTIVE
  COMPLETED
  FAILED
  DELAYED
  PAUSED
  CANCELLED
  STUCK
}

enum QueueStatus {
  ACTIVE
  PAUSED
  STOPPED
  ERROR
}

enum WorkerStatus {
  ACTIVE
  IDLE
  STOPPED
  ERROR
}

enum BackoffType {
  FIXED
  EXPONENTIAL
  LINEAR
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
  FATAL
}

scalar DateTime
scalar JSON