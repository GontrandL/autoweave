extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.3", import: ["@key", "@shareable", "@provides", "@requires", "@external", "@tag", "@inaccessible"])

type Query {
  metrics(tenantId: String, timeRange: TimeRange!): [Metric!]! @auth(requires: ["observability:read"])
  systemMetrics(timeRange: TimeRange!): SystemMetrics! @auth(requires: ["observability:admin"])
  logs(tenantId: String, level: LogLevel, component: String, limit: Int = 100): [LogEntry!]! @auth(requires: ["observability:read"])
  traces(tenantId: String, operationName: String, timeRange: TimeRange!): [Trace!]! @auth(requires: ["observability:read"])
  alerts(tenantId: String, status: AlertStatus): [Alert!]! @auth(requires: ["observability:read"])
  dashboards(tenantId: String): [Dashboard!]! @auth(requires: ["observability:read"])
  dashboard(id: ID!): Dashboard @auth(requires: ["observability:read"], tenantIsolated: true)
  healthChecks(tenantId: String): [HealthCheck!]! @auth(requires: ["observability:read"])
  performanceReport(tenantId: String, timeRange: TimeRange!): PerformanceReport! @auth(requires: ["observability:read"])
  auditLogs(tenantId: String, action: String, timeRange: TimeRange!): [AuditLog!]! @auth(requires: ["observability:admin"])
}

type Mutation {
  createAlert(input: CreateAlertInput!): Alert! @auth(requires: ["observability:admin"])
  updateAlert(id: ID!, input: UpdateAlertInput!): Alert! @auth(requires: ["observability:admin"], tenantIsolated: true)
  deleteAlert(id: ID!): Boolean! @auth(requires: ["observability:admin"], tenantIsolated: true)
  acknowledgeAlert(id: ID!): Alert! @auth(requires: ["observability:read"], tenantIsolated: true)
  createDashboard(input: CreateDashboardInput!): Dashboard! @auth(requires: ["observability:admin"])
  updateDashboard(id: ID!, input: UpdateDashboardInput!): Dashboard! @auth(requires: ["observability:admin"], tenantIsolated: true)
  deleteDashboard(id: ID!): Boolean! @auth(requires: ["observability:admin"], tenantIsolated: true)
  createHealthCheck(input: CreateHealthCheckInput!): HealthCheck! @auth(requires: ["observability:admin"])
  updateHealthCheck(id: ID!, input: UpdateHealthCheckInput!): HealthCheck! @auth(requires: ["observability:admin"], tenantIsolated: true)
  deleteHealthCheck(id: ID!): Boolean! @auth(requires: ["observability:admin"], tenantIsolated: true)
  exportMetrics(tenantId: String, timeRange: TimeRange!, format: ExportFormat!): String! @auth(requires: ["observability:read"])
  createAuditLog(input: CreateAuditLogInput!): AuditLog! @auth(requires: ["observability:admin"])
}

type Subscription {
  metricsStream(tenantId: String, metricName: String): Metric! @auth(requires: ["observability:read"])
  logsStream(tenantId: String, level: LogLevel, component: String): LogEntry! @auth(requires: ["observability:read"])
  alertsStream(tenantId: String): Alert! @auth(requires: ["observability:read"])
  healthStatusStream(tenantId: String): HealthCheck! @auth(requires: ["observability:read"])
}

type Metric @key(fields: "id") {
  id: ID!
  name: String!
  value: Float!
  unit: String!
  labels: JSON!
  timestamp: DateTime!
  tenantId: String!
  component: String!
  tags: [String!]!
  aggregationType: AggregationType!
  description: String
  threshold: MetricThreshold
  history: [MetricDataPoint!]!
}

type MetricDataPoint {
  timestamp: DateTime!
  value: Float!
  labels: JSON
}

type MetricThreshold {
  warning: Float
  critical: Float
  operator: ThresholdOperator!
}

type SystemMetrics {
  cpu: CPUMetrics!
  memory: MemoryMetrics!
  disk: DiskMetrics!
  network: NetworkMetrics!
  processes: ProcessMetrics!
  uptime: Float!
  loadAverage: [Float!]!
  timestamp: DateTime!
}

type CPUMetrics {
  usage: Float!
  cores: Int!
  frequency: Float!
  temperature: Float
  processes: [ProcessInfo!]!
}

type MemoryMetrics {
  total: Float!
  used: Float!
  free: Float!
  available: Float!
  usage: Float!
  swap: SwapMetrics!
}

type SwapMetrics {
  total: Float!
  used: Float!
  free: Float!
  usage: Float!
}

type DiskMetrics {
  total: Float!
  used: Float!
  free: Float!
  usage: Float!
  iops: Float!
  throughput: Float!
  partitions: [DiskPartition!]!
}

type DiskPartition {
  device: String!
  mountpoint: String!
  filesystem: String!
  total: Float!
  used: Float!
  free: Float!
  usage: Float!
}

type NetworkMetrics {
  bytesIn: Float!
  bytesOut: Float!
  packetsIn: Float!
  packetsOut: Float!
  errorsIn: Float!
  errorsOut: Float!
  interfaces: [NetworkInterface!]!
}

type NetworkInterface {
  name: String!
  bytesIn: Float!
  bytesOut: Float!
  packetsIn: Float!
  packetsOut: Float!
  errorsIn: Float!
  errorsOut: Float!
  isUp: Boolean!
}

type ProcessMetrics {
  total: Int!
  running: Int!
  sleeping: Int!
  stopped: Int!
  zombie: Int!
  threads: Int!
  processes: [ProcessInfo!]!
}

type ProcessInfo {
  pid: Int!
  name: String!
  cpu: Float!
  memory: Float!
  status: String!
  command: String!
  user: String!
  startTime: DateTime!
}

type LogEntry @key(fields: "id") {
  id: ID!
  timestamp: DateTime!
  level: LogLevel!
  message: String!
  component: String!
  tenantId: String!
  userId: String
  agentId: String
  requestId: String
  sessionId: String
  tags: [String!]!
  metadata: JSON!
  source: LogSource!
  stack: String
  error: LogError
}

type LogSource {
  file: String
  line: Int
  function: String
  host: String!
  service: String!
  version: String
}

type LogError {
  name: String!
  message: String!
  stack: String!
  code: String
  details: JSON
}

type Trace @key(fields: "id") {
  id: ID!
  traceId: String!
  spanId: String!
  parentSpanId: String
  operationName: String!
  startTime: DateTime!
  endTime: DateTime!
  duration: Float!
  status: TraceStatus!
  tenantId: String!
  userId: String
  agentId: String
  tags: JSON!
  logs: [TraceLog!]!
  spans: [Span!]!
  errors: [TraceError!]!
}

type Span {
  id: ID!
  traceId: String!
  spanId: String!
  parentSpanId: String
  operationName: String!
  startTime: DateTime!
  endTime: DateTime!
  duration: Float!
  status: SpanStatus!
  tags: JSON!
  logs: [SpanLog!]!
}

type SpanLog {
  timestamp: DateTime!
  level: LogLevel!
  message: String!
  fields: JSON!
}

type TraceLog {
  timestamp: DateTime!
  level: LogLevel!
  message: String!
  fields: JSON!
}

type TraceError {
  timestamp: DateTime!
  name: String!
  message: String!
  stack: String!
  span: Span!
}

type Alert @key(fields: "id") {
  id: ID!
  name: String!
  description: String!
  severity: AlertSeverity!
  status: AlertStatus!
  condition: AlertCondition!
  tenantId: String!
  createdBy: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  triggeredAt: DateTime
  acknowledgedAt: DateTime
  acknowledgedBy: String
  resolvedAt: DateTime
  resolvedBy: String
  silencedUntil: DateTime
  tags: [String!]!
  metadata: JSON!
  history: [AlertHistory!]!
  notifications: [AlertNotification!]!
}

type AlertCondition {
  metric: String!
  operator: ThresholdOperator!
  threshold: Float!
  duration: Int!
  query: String
  evaluationInterval: Int!
}

type AlertHistory {
  timestamp: DateTime!
  status: AlertStatus!
  message: String!
  triggeredBy: String
  metadata: JSON
}

type AlertNotification {
  id: ID!
  type: NotificationType!
  destination: String!
  message: String!
  sentAt: DateTime!
  status: NotificationStatus!
  retryCount: Int!
  error: String
}

type Dashboard @key(fields: "id") {
  id: ID!
  name: String!
  description: String
  tenantId: String!
  createdBy: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  isPublic: Boolean!
  tags: [String!]!
  panels: [DashboardPanel!]!
  variables: [DashboardVariable!]!
  timeRange: TimeRange!
  refreshInterval: Int!
  metadata: JSON!
}

type DashboardPanel {
  id: ID!
  title: String!
  type: PanelType!
  position: PanelPosition!
  size: PanelSize!
  query: String!
  visualization: PanelVisualization!
  options: JSON!
  thresholds: [PanelThreshold!]!
  datasource: String!
}

type PanelPosition {
  x: Int!
  y: Int!
}

type PanelSize {
  width: Int!
  height: Int!
}

type PanelVisualization {
  type: VisualizationType!
  options: JSON!
  legend: PanelLegend
  axes: PanelAxes
  colors: [String!]!
}

type PanelLegend {
  show: Boolean!
  position: LegendPosition!
  values: [String!]!
}

type PanelAxes {
  x: PanelAxis!
  y: PanelAxis!
}

type PanelAxis {
  label: String
  unit: String
  min: Float
  max: Float
  scale: ScaleType!
}

type PanelThreshold {
  value: Float!
  color: String!
  operator: ThresholdOperator!
}

type DashboardVariable {
  name: String!
  type: VariableType!
  query: String
  options: [String!]!
  defaultValue: String
  multiSelect: Boolean!
}

type HealthCheck @key(fields: "id") {
  id: ID!
  name: String!
  description: String
  endpoint: String!
  method: String!
  headers: JSON
  body: String
  timeout: Int!
  interval: Int!
  retries: Int!
  status: HealthStatus!
  tenantId: String!
  createdBy: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastChecked: DateTime
  lastSuccess: DateTime
  lastFailure: DateTime
  uptime: Float!
  responseTime: Float!
  tags: [String!]!
  history: [HealthCheckResult!]!
}

type HealthCheckResult {
  timestamp: DateTime!
  status: HealthStatus!
  responseTime: Float!
  statusCode: Int
  error: String
  response: String
}

type PerformanceReport {
  tenantId: String!
  timeRange: TimeRange!
  summary: PerformanceSummary!
  agents: [AgentPerformance!]!
  queues: [QueuePerformance!]!
  plugins: [PluginPerformance!]!
  system: SystemPerformance!
}

type PerformanceSummary {
  totalRequests: Int!
  avgResponseTime: Float!
  errorRate: Float!
  throughput: Float!
  uptime: Float!
  bottlenecks: [PerformanceBottleneck!]!
}

type PerformanceBottleneck {
  component: String!
  type: BottleneckType!
  severity: BottleneckSeverity!
  description: String!
  impact: Float!
  recommendation: String!
}

type AgentPerformance {
  agentId: String!
  name: String!
  avgResponseTime: Float!
  throughput: Float!
  errorRate: Float!
  cpuUsage: Float!
  memoryUsage: Float!
  uptime: Float!
}

type QueuePerformance {
  queueName: String!
  avgWaitTime: Float!
  throughput: Float!
  errorRate: Float!
  backlogSize: Int!
  processingTime: Float!
}

type PluginPerformance {
  pluginId: String!
  name: String!
  avgExecutionTime: Float!
  throughput: Float!
  errorRate: Float!
  cpuUsage: Float!
  memoryUsage: Float!
}

type SystemPerformance {
  cpuUsage: Float!
  memoryUsage: Float!
  diskUsage: Float!
  networkUsage: Float!
  loadAverage: Float!
  uptime: Float!
}

type AuditLog @key(fields: "id") {
  id: ID!
  timestamp: DateTime!
  tenantId: String!
  userId: String!
  action: String!
  resource: String!
  resourceId: String
  details: JSON!
  ipAddress: String!
  userAgent: String!
  sessionId: String
  outcome: AuditOutcome!
  risk: RiskLevel!
  tags: [String!]!
  metadata: JSON!
}

input CreateAlertInput {
  name: String!
  description: String
  severity: AlertSeverity!
  condition: AlertConditionInput!
  tags: [String!] = []
  notifications: [AlertNotificationInput!] = []
}

input UpdateAlertInput {
  name: String
  description: String
  severity: AlertSeverity
  condition: AlertConditionInput
  tags: [String!]
  notifications: [AlertNotificationInput!]
}

input AlertConditionInput {
  metric: String!
  operator: ThresholdOperator!
  threshold: Float!
  duration: Int!
  query: String
  evaluationInterval: Int! = 60
}

input AlertNotificationInput {
  type: NotificationType!
  destination: String!
  message: String
}

input CreateDashboardInput {
  name: String!
  description: String
  isPublic: Boolean = false
  tags: [String!] = []
  panels: [DashboardPanelInput!]!
  variables: [DashboardVariableInput!] = []
  timeRange: TimeRangeInput!
  refreshInterval: Int = 300
}

input UpdateDashboardInput {
  name: String
  description: String
  isPublic: Boolean
  tags: [String!]
  panels: [DashboardPanelInput!]
  variables: [DashboardVariableInput!]
  timeRange: TimeRangeInput
  refreshInterval: Int
}

input DashboardPanelInput {
  id: ID
  title: String!
  type: PanelType!
  position: PanelPositionInput!
  size: PanelSizeInput!
  query: String!
  visualization: PanelVisualizationInput!
  options: JSON = {}
  thresholds: [PanelThresholdInput!] = []
  datasource: String!
}

input PanelPositionInput {
  x: Int!
  y: Int!
}

input PanelSizeInput {
  width: Int!
  height: Int!
}

input PanelVisualizationInput {
  type: VisualizationType!
  options: JSON = {}
  legend: PanelLegendInput
  axes: PanelAxesInput
  colors: [String!] = []
}

input PanelLegendInput {
  show: Boolean = true
  position: LegendPosition = RIGHT
  values: [String!] = []
}

input PanelAxesInput {
  x: PanelAxisInput!
  y: PanelAxisInput!
}

input PanelAxisInput {
  label: String
  unit: String
  min: Float
  max: Float
  scale: ScaleType = LINEAR
}

input PanelThresholdInput {
  value: Float!
  color: String!
  operator: ThresholdOperator!
}

input DashboardVariableInput {
  name: String!
  type: VariableType!
  query: String
  options: [String!] = []
  defaultValue: String
  multiSelect: Boolean = false
}

input CreateHealthCheckInput {
  name: String!
  description: String
  endpoint: String!
  method: String! = "GET"
  headers: JSON = {}
  body: String
  timeout: Int! = 5000
  interval: Int! = 60
  retries: Int! = 3
  tags: [String!] = []
}

input UpdateHealthCheckInput {
  name: String
  description: String
  endpoint: String
  method: String
  headers: JSON
  body: String
  timeout: Int
  interval: Int
  retries: Int
  tags: [String!]
}

input TimeRange {
  start: DateTime!
  end: DateTime!
}

input TimeRangeInput {
  start: DateTime!
  end: DateTime!
}

input CreateAuditLogInput {
  action: String!
  resource: String!
  resourceId: String
  details: JSON!
  ipAddress: String!
  userAgent: String!
  sessionId: String
  outcome: AuditOutcome!
  risk: RiskLevel! = LOW
  tags: [String!] = []
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
  FATAL
}

enum AggregationType {
  COUNT
  SUM
  AVG
  MIN
  MAX
  RATE
  HISTOGRAM
  GAUGE
}

enum ThresholdOperator {
  GT
  GTE
  LT
  LTE
  EQ
  NEQ
}

enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum AlertStatus {
  ACTIVE
  PENDING
  ACKNOWLEDGED
  RESOLVED
  SILENCED
}

enum NotificationType {
  EMAIL
  SLACK
  WEBHOOK
  SMS
  PUSH
}

enum NotificationStatus {
  SENT
  FAILED
  PENDING
  DELIVERED
}

enum TraceStatus {
  OK
  ERROR
  TIMEOUT
  CANCELLED
}

enum SpanStatus {
  OK
  ERROR
  TIMEOUT
  CANCELLED
}

enum PanelType {
  GRAPH
  TABLE
  STAT
  GAUGE
  BAR_CHART
  PIE_CHART
  HEATMAP
  LOGS
  TEXT
}

enum VisualizationType {
  LINE
  BAR
  PIE
  GAUGE
  TABLE
  HEATMAP
  SCATTER
  AREA
}

enum LegendPosition {
  TOP
  BOTTOM
  LEFT
  RIGHT
  NONE
}

enum ScaleType {
  LINEAR
  LOG
  TIME
}

enum VariableType {
  QUERY
  CONSTANT
  DATASOURCE
  INTERVAL
  TEXTBOX
  CUSTOM
}

enum HealthStatus {
  HEALTHY
  DEGRADED
  UNHEALTHY
  UNKNOWN
}

enum ExportFormat {
  CSV
  JSON
  XLSX
  PDF
}

enum BottleneckType {
  CPU
  MEMORY
  DISK
  NETWORK
  DATABASE
  QUEUE
  PLUGIN
}

enum BottleneckSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum AuditOutcome {
  SUCCESS
  FAILURE
  PARTIAL
  DENIED
}

enum RiskLevel {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

scalar DateTime
scalar JSON